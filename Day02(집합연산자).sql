--집한연산자
-- UNION(합집합 중복X) , UNION ALL(합집합 중복O), INTERSECT(교집합), MONUS(차집합)
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION --미쉘이 중복이기 때문에 중복 제거
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION ALL --중복인 미쉘을 보여줌
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
INTERSECT
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
MINUS
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;
----------집합 연산자는 컬럼 수가 일치해야 합니다 ---------------------
--컬럼수가 일치한다면, 다양한 형태로 사용이 된다.
SELECT '홍길동', TO_CHAR(SYSDATE) FROM DUAL
UNION ALL
SELECT '이순신', '05/01/01' FROM DUAL
UNION ALL
SELECT 'REY', '06/02/02' FROM DUAL
UNION ALL
SELECT LAST_NAME, TO_CHAR(HIRE_DATE) FROM EMPLOYEES;
-----------------------------------------------------

--분석함수 : 행에 대한 결과를 출력하는 기능, OVER() 와 함께 사용
SELECT * FROM EMPLOYEES ORDER BY SALARY DESC;
SELECT SALARY, RANK() OVER(ORDER BY SALARY DESC) FROM EMPLOYEES ;

SELECT SALARY, RANK() OVER(ORDER BY SALARY DESC)AS 중복순서 , 
         DENSE_RANK() OVER(ORDER BY SALARY DESC)AS 중복순서X ,
         ROW_NUMBER() OVER(ORDER BY SALARY DESC)AS 데이터번호, 
         COUNT(*) OVER(ORDER BY SALARY DESC)AS 전체데이터갯수,
         ROWNUM 
FROM EMPLOYEES ;
-- ROWNUM은 조회가 일어난 순서 =>> ORDER BY를 사용하면 순서가 뒤바뀐다















